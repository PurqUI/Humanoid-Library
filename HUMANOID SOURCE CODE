local OrbitActive = false
local OrbitDistance = 10
local OrbitHeight = 5
local OrbitRandomness = 3
local SelectedTarget = nil -- Updated by the Target dropdown
local LocalPlayer = game.Players.LocalPlayer
local RunService = game:GetService("RunService")

local library = loadstring(game:HttpGet("https://raw.githubusercontent.com/PurqUI/Humanoid-Library/refs/heads/main/Library"))()

local window = library:new({textsize = 13.5,font = Enum.Font.RobotoMono,name = "Humanoid | PAID HVH | gg / mPQZ8dAtqE",color = Color3.fromRGB(225, 255, 255)})

local MainTab = window:page({name = "Aiming"})
local LegitTab = window:page({name = "Legit"})
local RageTab = window:page({name = "Rage"})
local VisualsTab = window:page({name = "Visuals"})
local TeleportsTab = window:page({name = "Teleport"})
local MiscTab = window:page({name = "Misc"})
local SettingsTab = window:page({name = "Settings"})

local CFrameSection = LegitTab:section({name = "Movement",side = "left",size = 150})
local AimingSection = MainTab:section({name = "Aiming",side = "left",size = 450})
local FiledOfViewSection = MainTab:section({name = "Field Of View",side = "right",size = 170})
local visualization = MainTab:section({name = "Visualization",side = "right",size = 110})
local PlayerTargetSection = RageTab:section({name = "Target Player",side = "left",size = 240})
local ChecksSection = MainTab:section({name = "Checks",side = "right",size = 100})
local OtherStuffSection = MainTab:section({name = "OtherStuff",side = "right",size = 100})
local ESPSection = VisualsTab:section({name = "ESP",side = "left",size = 200})
local HitDetectionSection = VisualsTab:section({name = "Hit Indicators",side = "left",size = 250})
local EspTargetSection = VisualsTab:section({name = "TargetEsp",side = "Right",size = 200})
local TeleportsSection = TeleportsTab:section({name = "Food ",side = "left",size = 130})
local PlacesSection = TeleportsTab:section({name = "Places ",side = "left",size = 180})
local ArmourTeleportSection = TeleportsTab:section({name = "Armour",side = "left",size = 80})
local GunsTeleport = TeleportsTab:section({name = "Guns",side = "right",size = 140})
local RageLockSection = RageTab:section({name = "Rage Lock",side = "right",size = 90})
local OpStuffSection = RageTab:section({name = "op stuff",side = "right",size = 230})
local OtherSection = RageTab:section({name = "Other",side = "left",size = 80})

-- Services
local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")
local LocalPlayer = game.Players.LocalPlayer

-- Services
local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")
local LocalPlayer = game.Players.LocalPlayer

-- Variables
local flying = false
local speed = 50 -- Default fly speed
local activeKeys = {}
local flyConnection -- To store the RenderStepped connection
local FlyKey = Enum.KeyCode.X -- Keybind for toggling Velocity Fly
local velocityFlyEnabled = false -- Tracks the state of the UI toggle

-- Function to start flying
local function startFlying()
    if not velocityFlyEnabled then return end -- Prevent flying if the toggle is disabled
    flying = true
    local character = LocalPlayer.Character
    if character and character:FindFirstChild("HumanoidRootPart") then
        local rootPart = character.HumanoidRootPart

        -- Fly loop
        flyConnection = RunService.RenderStepped:Connect(function(deltaTime)
            if flying then
                -- Calculate movement direction relative to the camera
                local camera = workspace.CurrentCamera
                local moveDirection = Vector3.new(0, 0, 0)

                if activeKeys["W"] then
                    moveDirection = moveDirection + camera.CFrame.LookVector
                end
                if activeKeys["S"] then
                    moveDirection = moveDirection - camera.CFrame.LookVector
                end
                if activeKeys["A"] then
                    moveDirection = moveDirection - camera.CFrame.RightVector
                end
                if activeKeys["D"] then
                    moveDirection = moveDirection + camera.CFrame.RightVector
                end
                if activeKeys["Space"] then
                    moveDirection = moveDirection + Vector3.new(0, 1, 0) -- Move up
                end
                if activeKeys["LeftShift"] then
                    moveDirection = moveDirection - Vector3.new(0, 1, 0) -- Move down
                end

                -- Normalize direction and apply speed
                if moveDirection.Magnitude > 0 then
                    moveDirection = moveDirection.Unit * speed
                end
                rootPart.AssemblyLinearVelocity = moveDirection
            else
                rootPart.AssemblyLinearVelocity = Vector3.new(0, 0, 0) -- Stop movement when flying is disabled
            end
        end)
    end
end

-- Function to stop flying
local function stopFlying()
    flying = false
    local character = LocalPlayer.Character
    if character and character:FindFirstChild("HumanoidRootPart") then
        local rootPart = character.HumanoidRootPart
        rootPart.AssemblyLinearVelocity = Vector3.new(0, 0, 0) -- Reset velocity
    end

    if flyConnection then
        flyConnection:Disconnect() -- Disconnect the RenderStepped connection
        flyConnection = nil
    end
end

-- Handle input for flying
UserInputService.InputBegan:Connect(function(input, gameProcessed)
    if gameProcessed then return end

    -- Track movement keys
    if flying then
        if input.KeyCode == Enum.KeyCode.W then
            activeKeys["W"] = true
        elseif input.KeyCode == Enum.KeyCode.S then
            activeKeys["S"] = true
        elseif input.KeyCode == Enum.KeyCode.A then
            activeKeys["A"] = true
        elseif input.KeyCode == Enum.KeyCode.D then
            activeKeys["D"] = true
        elseif input.KeyCode == Enum.KeyCode.Space then
            activeKeys["Space"] = true
        elseif input.KeyCode == Enum.KeyCode.LeftShift then
            activeKeys["LeftShift"] = true
        end
    end

    -- Toggle flying with the keybind
    if input.KeyCode == FlyKey and velocityFlyEnabled then
        if flying then
            stopFlying()
            print("Velocity Fly disabled via keybind.")
        else
            startFlying()
            print("Velocity Fly enabled via keybind.")
        end
    end
end)

UserInputService.InputEnded:Connect(function(input)
    -- Stop movement in the released direction
    if flying then
        if input.KeyCode == Enum.KeyCode.W then
            activeKeys["W"] = false
        elseif input.KeyCode == Enum.KeyCode.S then
            activeKeys["S"] = false
        elseif input.KeyCode == Enum.KeyCode.A then
            activeKeys["A"] = false
        elseif input.KeyCode == Enum.KeyCode.D then
            activeKeys["D"] = false
        elseif input.KeyCode == Enum.KeyCode.Space then
            activeKeys["Space"] = false
        elseif input.KeyCode == Enum.KeyCode.LeftShift then
            activeKeys["LeftShift"] = false
        end
    end
end)

-- Toggle for enabling/disabling Velocity Fly
CFrameSection:toggle({
    name = "Velocity Fly X",
    def = false,
    callback = function(value)
        velocityFlyEnabled = value -- Update the state of the toggle
        if value then
            print("Velocity Fly enabled.")
        else
            stopFlying() -- Ensure flying is stopped when the toggle is disabled
            print("Velocity Fly disabled.")
        end
    end
})

-- Slider for adjusting Velocity Fly speed
CFrameSection:slider({
    name = "Velocity Fly Speed",
    def = 50, -- Default speed
    max = 300, -- Updated maximum speed
    min = 10, -- Minimum speed
    rounding = false,
    callback = function(value)
        speed = value -- Update the fly speed
        print("Velocity Fly Speed set to:", value)
    end
})

CFrameSection:toggle({name = "CFrame Walk Speed",def = false,callback = function(value)
    tog = value
    print(tog)
end})

CFrameSection:slider({name = "CFrame Speed",def = 1, max = 30,min = 1,rounding = false,ticking = false,measuring = "",callback = function(value)
    print(value)
end})

    
    
local AimbotEnabled = false -- Controlled by the toggle
local AimbotActive = false -- Controlled by the keybind (Z)
local CurrentTarget = nil
local FOVRadius = 200 -- Adjust the FOV radius as needed
local Camera = workspace.CurrentCamera
local Players = game:GetService("Players")
local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")
local AimKey = Enum.KeyCode.Z -- Keybind for toggling lock-on

-- Function to find the closest player within the FOV
local function findClosestPlayer()
    local closestPlayer = nil
    local shortestDistance = FOVRadius

    for _, player in ipairs(Players:GetPlayers()) do
        if player ~= LocalPlayer and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
            local rootPart = player.Character.HumanoidRootPart
            local screenPos, onScreen = Camera:WorldToViewportPoint(rootPart.Position)

            if onScreen then
                local mousePos = UserInputService:GetMouseLocation()
                local distance = (Vector2.new(screenPos.X, screenPos.Y) - mousePos).Magnitude

                if distance < shortestDistance then
                    shortestDistance = distance
                    closestPlayer = player
                end
            end
        end
    end

    return closestPlayer
end

-- Variables
local PredictionStrength = 0.35 -- Default prediction strength
local SelectedAimPart = "HumanoidRootPart" -- Default aim part

-- Utility: Predict Target Position
local function predictTargetPosition(target)
    if target and target.Character and target.Character:FindFirstChild(SelectedAimPart) then
        local targetPart = target.Character[SelectedAimPart]
        local velocity = targetPart.Velocity
        local predictedPosition = targetPart.Position + (velocity * PredictionStrength)
        return predictedPosition
    end
    return nil
end

-- Utility: Find Closest Player
local function findClosestPlayer()
    local closestPlayer = nil
    local shortestDistance = FOVRadius

    for _, player in ipairs(Players:GetPlayers()) do
        if player ~= LocalPlayer and player.Character and player.Character:FindFirstChild(SelectedAimPart) then
            local targetPart = player.Character[SelectedAimPart]
            local screenPos, onScreen = Camera:WorldToViewportPoint(targetPart.Position)

            if onScreen then
                local mousePos = UserInputService:GetMouseLocation()
                local distance = (Vector2.new(screenPos.X, screenPos.Y) - mousePos).Magnitude

                if distance < shortestDistance then
                    shortestDistance = distance
                    closestPlayer = player
                end
            end
        end
    end

    return closestPlayer
end

-- Aimbot Toggle
AimingSection:toggle({
    name = "Aimbot (Z)",
    def = false,
    callback = function(value)
        AimbotEnabled = value

        if not AimbotEnabled then
            AimbotActive = false
            CurrentTarget = nil
            print("Aimbot Disabled.")
        else
            print("Aimbot Enabled. Press Z to lock onto a target.")
        end
    end
})

-- Keybind to toggle lock-on
UserInputService.InputBegan:Connect(function(input, gameProcessed)
    if gameProcessed then return end

    if input.KeyCode == AimKey and AimbotEnabled then
        AimbotActive = not AimbotActive

        if AimbotActive then
            -- Find the closest player to target
            CurrentTarget = findClosestPlayer()
            if CurrentTarget then
                print("Lock-on Enabled. Targeting:", CurrentTarget.Name)
            else
                print("Lock-on Enabled. No target found.")
            end
        else
            -- Disable lock-on
            CurrentTarget = nil
            print("Lock-on Disabled.")
        end
    end
end)

-- Aimbot Logic (runs every frame if lock-on is active)
RunService.RenderStepped:Connect(function()
    if AimbotEnabled and AimbotActive and CurrentTarget and CurrentTarget.Character and CurrentTarget.Character:FindFirstChild(SelectedAimPart) then
        local targetPart = CurrentTarget.Character[SelectedAimPart]
        if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
            -- Predict target position
            local predictedPosition = predictTargetPosition(CurrentTarget)
            if predictedPosition then
                -- Smoothly lock the camera onto the predicted position
                local cameraPosition = Camera.CFrame.Position
                local direction = (predictedPosition - cameraPosition).Unit
                Camera.CFrame = CFrame.new(cameraPosition, cameraPosition + direction)
            end
        end
    end
end)

-- Textbox for adjusting Prediction Strength
AimingSection:textbox({
    name = "Prediction",
    def = tostring(PredictionStrength),
    placeholder = "Prediction Strength",
    callback = function(value)
        local numValue = tonumber(value)
        if numValue then
            PredictionStrength = numValue
            print("Prediction Strength set to:", PredictionStrength)
        else
            print("Invalid Prediction Strength value.")
        end
    end
})

-- Multibox for selecting Aim Part
AimingSection:dropdown({
    name = "Aim Part",
    def = "HumanoidRootPart", -- Default selection
    options = {"Head", "HumanoidRootPart", "LowerTorso"}, -- Fixed options
    callback = function(chosen)
        if chosen then
            SelectedAimPart = chosen -- Update the selected aim part
            print("Selected Aim Part:", SelectedAimPart)
        else
            print("No Aim Part selected. Defaulting to HumanoidRootPart.")
            SelectedAimPart = "HumanoidRootPart"
        end
    end
})

-- Variables
local SoftAimActive = false
local SoftAimKey = Enum.KeyCode.V -- Keybind for toggling Soft Aim
local PredictionStrength = 0.35 -- Default prediction strength

-- Utility: Predict Target Position
local function predictTargetPosition(target)
    if target and target.Character and target.Character:FindFirstChild("HumanoidRootPart") then
        local rootPart = target.Character.HumanoidRootPart
        local velocity = rootPart.Velocity
        local predictedPosition = rootPart.Position + (velocity * PredictionStrength)
        return predictedPosition
    end
    return nil
end

-- Utility: Find Closest Player
local function findClosestPlayer()
    local closestPlayer = nil
    local shortestDistance = FOVRadius

    for _, player in ipairs(Players:GetPlayers()) do
        if player ~= LocalPlayer and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
            local rootPart = player.Character.HumanoidRootPart
            local screenPos, onScreen = Camera:WorldToViewportPoint(rootPart.Position)

            if onScreen then
                local mousePos = UserInputService:GetMouseLocation()
                local distance = (Vector2.new(screenPos.X, screenPos.Y) - mousePos).Magnitude

                if distance < shortestDistance then
                    shortestDistance = distance
                    closestPlayer = player
                end
            end
        end
    end

    return closestPlayer
end

-- Soft Aim Logic
local function softAimLogic()
    RunService.RenderStepped:Connect(function()
        if SoftAimActive and CurrentTarget and CurrentTarget.Character and CurrentTarget.Character:FindFirstChild("HumanoidRootPart") then
            local predictedPosition = predictTargetPosition(CurrentTarget)

            if predictedPosition then
                -- Smoothly adjust the camera to aim at the predicted position
                Camera.CFrame = Camera.CFrame:Lerp(CFrame.new(Camera.CFrame.Position, predictedPosition), 0.3)
            end
        end
    end)
end

-- Toggle for Soft Aim
AimingSection:toggle({
    name = "SoftAim (V)",
    def = false,
    callback = function(value)
        SoftAimEnabled = value -- Track whether the toggle is enabled
        if not SoftAimEnabled then
            SoftAimActive = false -- Disable Soft Aim if the toggle is turned off
            CurrentTarget = nil -- Clear the target
            print("Soft Aim Disabled via toggle.")
        else
            print("Soft Aim Enabled via toggle.")
        end
    end
})

-- Textbox for adjusting Prediction Strength
AimingSection:textbox({
    name = "Prediction",
    def = tostring(PredictionStrength),
    placeholder = "Prediction Strength",
    callback = function(value)
        local numValue = tonumber(value)
        if numValue then
            PredictionStrength = numValue
            print("Prediction Strength set to:", PredictionStrength)
        else
            print("Invalid Prediction Strength value.")
        end
    end
})

-- Keybind for Soft Aim
UserInputService.InputBegan:Connect(function(input, gameProcessed)
    if gameProcessed then return end

    if input.KeyCode == SoftAimKey then
        if SoftAimEnabled then -- Ensure the toggle is enabled
            SoftAimActive = not SoftAimActive -- Toggle Soft Aim on/off

            if SoftAimActive then
                CurrentTarget = findClosestPlayer()
                if CurrentTarget then
                    print("Soft Aim Enabled. Targeting:", CurrentTarget.Name)
                else
                    print("Soft Aim Enabled. No target found.")
                end
            else
                CurrentTarget = nil -- Clear the target when deactivating
                print("Soft Aim Disabled.")
            end
        else
            print("Soft Aim is disabled. Enable it via the toggle first.")
        end
    end
end)

-- Start Soft Aim Logic
softAimLogic()

-- === SILENT AIM WITH FOV & TRACER === By @Cert1FiedSoulz

local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer
local Camera = workspace.CurrentCamera
local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")

-- State variables controlled by UI
local SilentAimEnabled = false
local ShowFov = true
local FOVColor = Color3.fromRGB(255,255,255)
local fovRadius = 300
local SilentAimHitPart = "HumanoidRootPart"

-- FOV and Tracer Drawing
local fovCircle = Drawing.new("Circle")
fovCircle.Thickness = 2
fovCircle.NumSides = 100
fovCircle.Radius = fovRadius
fovCircle.Filled = false
fovCircle.Color = FOVColor
fovCircle.Visible = ShowFov

local tracer = Drawing.new("Line")
tracer.Thickness = 2
tracer.Color = FOVColor
tracer.Visible = ShowFov

-- UI Integration
AimingSection:toggle({
    name = "Silent Aim",
    def = false,
    callback = function(value)
        SilentAimEnabled = value
        print("Silent Aim:", value)
    end
})

AimingSection:toggle({
    name = "Show Fov",
    def = true,
    callback = function(value)
        ShowFov = value
        fovCircle.Visible = value
        tracer.Visible = value
        print("Show Fov:", value)
    end
})

AimingSection:colorpicker({
    name = "FOV Color",
    cpname = nil,
    def = Color3.fromRGB(255,255,255),
    callback = function(value)
        FOVColor = value
        fovCircle.Color = value
        tracer.Color = value
        print("FOV Color:", value)
    end
})

AimingSection:dropdown({
    name = "Hit Part Silent Aim",
    def = "HumanoidRootPart",
    max = 2,
    options = {"HumanoidRootPart","Head","LowerTorso"},
    callback = function(chosen)
        SilentAimHitPart = chosen
        print("Silent Aim Hit Part:", chosen)
    end
})

AimingSection:slider({
    name = "FOV Size",
    def = 300,
    max = 600,
    min = 50,
    rounding = true,
    callback = function(value)
        fovRadius = value
        fovCircle.Radius = value
        print("FOV Size:", value)
    end
})

-- Find closest player to mouse within FOV
local function getClosestToMouseInFOV()
    local mousePos = UserInputService:GetMouseLocation()
    local closest, shortest = nil, math.huge
    for _, player in ipairs(Players:GetPlayers()) do
        if player ~= LocalPlayer and player.Character and player.Character:FindFirstChild(SilentAimHitPart) then
            local part = player.Character[SilentAimHitPart]
            local screenPos, onScreen = Camera:WorldToViewportPoint(part.Position)
            if onScreen then
                local dist = (Vector2.new(screenPos.X, screenPos.Y) - mousePos).Magnitude
                if dist < shortest and dist <= fovRadius then
                    shortest = dist
                    closest = player
                end
            end
        end
    end
    return closest
end

-- Predict position
local function getPredictedPosition(target)
    if not (target and target.Character and target.Character:FindFirstChild(SilentAimHitPart)) then
        return nil
    end
    local part = target.Character[SilentAimHitPart]
    local targetPos = part.Position
    local targetVel = part.Velocity
    local camPos = Camera.CFrame.Position
    local bulletSpeed = 200 -- You can make this a global if you want

    local distance = (targetPos - camPos).Magnitude
    local travelTime = distance / bulletSpeed

    local predicted = targetPos + targetVel * travelTime
    return predicted
end

-- Update FOV circle and tracer every frame
RunService.RenderStepped:Connect(function()
    fovCircle.Visible = ShowFov
    tracer.Visible = ShowFov
    fovCircle.Radius = fovRadius
    fovCircle.Color = FOVColor
    tracer.Color = FOVColor

    local mousePos = UserInputService:GetMouseLocation()
    fovCircle.Position = mousePos

    local Target = getClosestToMouseInFOV()
    if Target and ShowFov then
        local predicted = getPredictedPosition(Target)
        if predicted then
            local screenPos, onScreen = Camera:WorldToViewportPoint(predicted)
            if onScreen then
                tracer.From = mousePos
                tracer.To = Vector2.new(screenPos.X, screenPos.Y)
                tracer.Visible = true
            else
                tracer.Visible = false
            end
        else
            tracer.Visible = false
        end
    else
        tracer.Visible = false
    end
end)

-- Silent aim logic: redirect Mouse.Hit to predicted position
local Mouse = LocalPlayer:GetMouse()
local mt = getrawmetatable(game)
local oldIndex = mt.__index
setreadonly(mt, false)
mt.__index = function(self, key)
    if self == Mouse and key == "Hit" and SilentAimEnabled then
        local target = getClosestToMouseInFOV()
        if target then
            local predicted = getPredictedPosition(target)
            if predicted then
                return CFrame.new(predicted)
            end
        end
    end
    return oldIndex(self, key)
end
setreadonly(mt, true)

AimingSection:textbox({name = "Prediction",def = "0.35",placeholder = "Prediction Strength",callback = function(value)
        print(value)
end})

-- FOV Drawing Logic
local fovCircle = Drawing.new("Circle")
fovCircle.Visible = false -- Initially hidden
fovCircle.Radius = FOVRadius -- Default radius
fovCircle.Thickness = 1
fovCircle.Color = Color3.fromRGB(255, 255, 255) -- Default color
fovCircle.Transparency = 0.75
fovCircle.Filled = false

RunService.RenderStepped:Connect(function()
    if fovCircle.Visible then
        local mousePos = UserInputService:GetMouseLocation()
        fovCircle.Position = Vector2.new(mousePos.X, mousePos.Y)
    end
end)

-- Toggle for enabling/disabling FOV
AimingSection:toggle({
    name = "Enable FOV",
    def = false,
    callback = function(value)
        fovCircle.Visible = value -- Show or hide the FOV circle
        print("FOV Enabled:", value)
    end
})

-- Slider for adjusting FOV Size
AimingSection:slider({
    name = "FOV Size",
    def = FOVRadius, -- Default FOV size
    max = 300, -- Maximum FOV size
    min = 25, -- Minimum FOV size
    rounding = true,
    ticking = false,
    measuring = "",
    callback = function(value)
        fovCircle.Radius = value -- Update the FOV circle's radius dynamically
        print("FOV Size set to:", value)
    end
})

-- Color Picker for FOV Color
local FOVPicker = AimingSection:colorpicker({
    name = "FOV Color",
    cpname = nil,
    def = Color3.fromRGB(255, 255, 255), -- Default color
    callback = function(value)
        fovCircle.Color = value -- Update the FOV circle's color dynamically
        print("FOV Color set to:", value)
    end
})

ChecksSection:toggle({name = "Friend Check",def = false,callback = function(value)
    tog = value
    print(tog)
end})

ChecksSection:toggle({name = "Wall Check",def = false,callback = function(value)
    tog = value
    print(tog)
end})

ChecksSection:toggle({name = "Visible Check",def = false,callback = function(value)
    tog = value
    print(tog)
end})

ChecksSection:toggle({name = "Dead Check",def = false,callback = function(value)
    tog = value
    print(tog)
end})

PlayerTargetSection:dropdown({
    name = "Target",
    def = "",
    max = 10,
    options = (function()
        local players = {}
        for _, player in ipairs(game:GetService("Players"):GetPlayers()) do
            if player ~= game.Players.LocalPlayer then
                table.insert(players, player.Name)
            end
        end
        return players
    end)(),
    callback = function(chosen)
        SelectedTarget = game:GetService("Players"):FindFirstChild(chosen)
        if SelectedTarget then
            print("Selected Target:", SelectedTarget.Name)
        else
            print("Invalid target selected.")
        end
    end
})

PlayerTargetSection:toggle({name = "Stomp Target",def = false,callback = function(value)
    tog = value
    print(tog)
end})

PlayerTargetSection:toggle({name = "Knock Target",def = false,callback = function(value)
    tog = value
    print(tog)
end})

PlayerTargetSection:toggle({name = "Grab Target",def = false,callback = function(value)
    tog = value
    print(tog)
end})

PlayerTargetSection:toggle({
    name = "Orbit Target",
    def = false,
    callback = function(value)
        OrbitActive = value
        if OrbitActive then
            if SelectedTarget and SelectedTarget.Character and SelectedTarget.Character:FindFirstChild("HumanoidRootPart") then
                local rootPart = SelectedTarget.Character.HumanoidRootPart
                local humanoid = SelectedTarget.Character:FindFirstChild("Humanoid")
                print("Orbiting around:", SelectedTarget.Name)

                -- Start orbiting in a coroutine
                task.spawn(function()
                    while OrbitActive and rootPart and humanoid do
                        RunService.RenderStepped:Wait()

                        -- Validate target
                        if not SelectedTarget or not SelectedTarget.Character or not SelectedTarget.Character:FindFirstChild("HumanoidRootPart") or humanoid.Health <= 0 then
                            -- Check if the target is stomped (fully dead)
                            if not SelectedTarget.Character or not SelectedTarget.Character:FindFirstChild("HumanoidRootPart") then
                                print("Target is stomped or fully dead. Stopping orbit.")
                                OrbitActive = false
                                PlayerTargetSection.flags["Orbit Target"] = false -- Disable the toggle
                                break
                            end
                        end

                        -- Generate random offsets for spazzing
                        local randomOffsetX = math.random(-OrbitRandomness * 5, OrbitRandomness * 5)
                        local randomOffsetY = math.random(-OrbitRandomness * 2, OrbitRandomness * 2)
                        local randomOffsetZ = math.random(-OrbitRandomness * 5, OrbitRandomness * 5)

                        -- Calculate the orbit position with spazzing
                        local angle = tick() * 2 -- Use time to create a smooth orbit
                        local orbitX = math.cos(angle) * OrbitDistance
                        local orbitZ = math.sin(angle) * OrbitDistance
                        local orbitPosition = rootPart.Position + Vector3.new(orbitX + randomOffsetX, OrbitHeight + randomOffsetY, orbitZ + randomOffsetZ)

                        -- Move the character's HumanoidRootPart to the orbit position
                        if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
                            LocalPlayer.Character.HumanoidRootPart.CFrame = CFrame.new(orbitPosition, rootPart.Position)
                        end

                        -- Lock camera onto the target
                        local cameraPosition = workspace.CurrentCamera.CFrame.Position
                        workspace.CurrentCamera.CFrame = CFrame.new(cameraPosition, rootPart.Position)
                    end
                end)
            else
                print("No valid target selected or target has no HumanoidRootPart.")
                OrbitActive = false
            end
        else
            print("Stopped orbiting.")
        end
    end
})

PlayerTargetSection:toggle({
    name = "AutoKill Target",
    def = false,
    callback = function(value)
        OrbitActive = value
        if OrbitActive then
            if SelectedTarget and SelectedTarget.Character and SelectedTarget.Character:FindFirstChild("HumanoidRootPart") then
                local targetRootPart = SelectedTarget.Character.HumanoidRootPart
                local localCharacter = LocalPlayer.Character

                if localCharacter and localCharacter:FindFirstChild("HumanoidRootPart") then
                    print("AutoKill Target enabled. Locking onto and orbiting:", SelectedTarget.Name)

                    -- Start orbiting and locking onto the target
                    task.spawn(function()
                        while OrbitActive do
                            task.wait(0.05) -- Throttle the loop to reduce load

                            -- Validate target
                            if not SelectedTarget or not SelectedTarget.Character or not SelectedTarget.Character:FindFirstChild("HumanoidRootPart") then
                                print("Target is no longer valid. Stopping AutoKill.")
                                OrbitActive = false
                                PlayerTargetSection.flags["AutoKill Target"] = false -- Disable the toggle
                                break
                            end

                            -- Check if the target is knocked or has 0 health
                            local humanoid = SelectedTarget.Character:FindFirstChild("Humanoid")
                            if humanoid and humanoid.Health <= 0 then
                                print("Target knocked or has 0 health. Stopping AutoKill.")
                                OrbitActive = false
                                PlayerTargetSection.flags["AutoKill Target"] = false -- Disable the toggle
                                break
                            end

                            -- Orbit logic
                            local randomOffsetX = math.random(-OrbitRandomness, OrbitRandomness)
                            local randomOffsetZ = math.random(-OrbitRandomness, OrbitRandomness)
                            local behindPosition = targetRootPart.Position - (targetRootPart.CFrame.LookVector * OrbitDistance) + Vector3.new(randomOffsetX, OrbitHeight, randomOffsetZ)

                            if localCharacter and localCharacter:FindFirstChild("HumanoidRootPart") then
                                localCharacter.HumanoidRootPart.CFrame = CFrame.new(behindPosition, targetRootPart.Position)
                            end

                            -- Lock-on logic
                            local targetPosition = targetRootPart.Position
                            local cameraPosition = Camera.CFrame.Position
                            Camera.CFrame = CFrame.new(cameraPosition, targetPosition)
                        end

                        -- Ensure everything resets properly
                        OrbitActive = false
                        print("AutoKill Target disabled.")
                    end)
                else
                    print("Local player does not have a HumanoidRootPart.")
                    OrbitActive = false
                    PlayerTargetSection.flags["AutoKill Target"] = false -- Disable the toggle
                end
            else
                print("No valid target selected or target does not have a HumanoidRootPart.")
                OrbitActive = false
                PlayerTargetSection.flags["AutoKill Target"] = false -- Disable the toggle
            end
        else
            -- Disable AutoKill
            OrbitActive = false
            print("AutoKill Target disabled.")
        end
    end
})

PlayerTargetSection:toggle({
    name = "Goto Target",
    def = false,
    callback = function(value)
        if value then
            if SelectedTarget and SelectedTarget.Character and SelectedTarget.Character:FindFirstChild("HumanoidRootPart") then
                local targetRootPart = SelectedTarget.Character.HumanoidRootPart
                if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
                    -- Teleport the local player to the target's position
                    LocalPlayer.Character.HumanoidRootPart.CFrame = targetRootPart.CFrame
                    print("Teleported to:", SelectedTarget.Name)
                else
                    print("Local player does not have a HumanoidRootPart.")
                end
            else
                print("No valid target selected or target does not have a HumanoidRootPart.")
            end
        else
            print("Goto Target disabled.")
        end
    end
})

local viewConnection -- To store the RenderStepped connection

PlayerTargetSection:toggle({
    name = "View Target",
    def = false,
    callback = function(value)
        if value then
            if SelectedTarget and SelectedTarget.Character and SelectedTarget.Character:FindFirstChild("HumanoidRootPart") then
                local targetRootPart = SelectedTarget.Character.HumanoidRootPart
                local camera = workspace.CurrentCamera

                -- Start viewing the target
                viewConnection = RunService.RenderStepped:Connect(function()
                    if SelectedTarget and SelectedTarget.Character and SelectedTarget.Character:FindFirstChild("HumanoidRootPart") then
                        camera.CFrame = CFrame.new(targetRootPart.Position + Vector3.new(0, 5, -10), targetRootPart.Position)
                    else
                        print("Target is no longer valid.")
                    end
                end)
            else
                print("No valid target selected or target does not have a HumanoidRootPart.")
            end
        else
            -- Stop viewing the target
            if viewConnection then
                viewConnection:Disconnect()
                viewConnection = nil
            end

            -- Reset the camera to the local player's view
            local localCharacter = LocalPlayer.Character
            if localCharacter and localCharacter:FindFirstChild("Humanoid") then
                workspace.CurrentCamera.CameraSubject = localCharacter.Humanoid
                print("Stopped viewing the target.")
            end
        end
    end
})

PlayerTargetSection:toggle({
    name = "Fling Target",
    def = false,
    callback = function(value)
end})

OpStuffSection:toggle({
    name = "Remove Fire Rate",
    def = false,
    callback = function(value)
        if value then
            -- Enable Remove Fire Rate logic
            if game.PlaceId == 2788229376 and LocalPlayer.Character and LocalPlayer.Character:FindFirstChildOfClass("Tool") and LocalPlayer.Character:FindFirstChildOfClass("Tool"):FindFirstChild("GunScript") then
                for _, v in ipairs(getconnections(LocalPlayer.Character:FindFirstChildOfClass("Tool").Activated)) do
                    if v.Function and type(v.Function) == "function" then
                        local funcinfo = debug.getinfo(v.Function)
                        if funcinfo then
                            for i = 1, funcinfo.nups do
                                local c, n = debug.getupvalue(v.Function, i)
                                if type(c) == "number" then
                                    debug.setupvalue(v.Function, i, 0) -- Set the value to 0 to remove fire rate
                                end
                            end
                        end
                    end
                end
            elseif game.PlaceId == 9825515356 and LocalPlayer.Character and LocalPlayer.Character:FindFirstChildOfClass("Tool") then
                local Gun = LocalPlayer.Character:FindFirstChildOfClass("Tool")
                if Gun and Gun:FindFirstChild("GunData") then
                    local Module = require(Gun:FindFirstChild("GunData"))
                    Module["slowdown_time"] = 0
                    Module["cooldown"] = 0
                end
            end
            print("Remove Fire Rate enabled.")
        else
            -- Disable Remove Fire Rate logic
            print("Remove Fire Rate disabled.")
        end
    end
})

OpStuffSection:toggle({
    name = "Magic Bullet",
    def = false,
    callback = function(value)
end})

OpStuffSection:toggle({
    name = "Force Hit",
    def = false,
    callback = function(value)
end})

OpStuffSection:toggle({
    name = "Prefire ForceField",
    def = false,
    callback = function(value)
end})

OpStuffSection:toggle({
    name = "Look At Target",
    def = false,
    callback = function(value)
end})

OpStuffSection:multibox({name = "HitPart",def = {}, max = 4,options = {"Head","HumanoidRootPart","LowerTorso"},callback = function(value)
    print(value)
    end})

    OpStuffSection:multibox({name = "Air HitPart",def = {}, max = 4,options = {"Head","HumanoidRootPart","LowerTorso"},callback = function(value)
    print(value)
    end})

-- Services
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local Camera = workspace.CurrentCamera
local LocalPlayer = Players.LocalPlayer

-- Settings
local ESPEnabled = false
local TracersEnabled = false
local OutlineEnabled = false
local CornerBoxEnabled = false
local TextSize = 12 -- Username text size
local LineThickness = 1 -- Tracer line thickness
local GlowTransparency = 0.5 -- Transparency for glowing outlines

-- Function to create ESP for a player
local function createESP(player)
    if player == LocalPlayer then return end

    -- ESP Components
    local box = Drawing.new("Square")
    box.Visible = false
    box.Color = Color3.fromRGB(255, 255, 255)
    box.Thickness = 1
    box.Transparency = GlowTransparency
    box.Filled = false

    local tracer = Drawing.new("Line")
    tracer.Visible = false
    tracer.Color = Color3.fromRGB(255, 255, 255)
    tracer.Thickness = LineThickness
    tracer.Transparency = GlowTransparency

    local username = Drawing.new("Text")
    username.Visible = false
    username.Color = Color3.fromRGB(255, 255, 255)
    username.Size = TextSize
    username.Center = true
    username.Outline = true
    username.Text = player.Name

    -- Corner Box Components
    local corners = {}
    for i = 1, 8 do
        local line = Drawing.new("Line")
        line.Visible = false
        line.Color = Color3.fromRGB(255, 255, 255)
        line.Thickness = 1
        table.insert(corners, line)
    end

    -- Update ESP every frame
    local function updateESP()
        if not player.Character or not player.Character:FindFirstChild("HumanoidRootPart") or not player.Character:FindFirstChild("Head") then
            box.Visible = false
            tracer.Visible = false
            username.Visible = false
            for _, line in ipairs(corners) do
                line.Visible = false
            end
            return
        end

        local rootPart = player.Character.HumanoidRootPart
        local head = player.Character.Head
        local rootPos, onScreen = Camera:WorldToViewportPoint(rootPart.Position)
        local headPos = Camera:WorldToViewportPoint(head.Position)

        if onScreen then
            -- Update box
            local size = Vector2.new(50, 100) -- Box size
            box.Size = size
            box.Position = Vector2.new(rootPos.X - size.X / 2, rootPos.Y - size.Y / 2)
            box.Visible = OutlineEnabled

            -- Update tracer
            tracer.From = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y) -- Bottom center of the screen
            tracer.To = Vector2.new(rootPos.X, rootPos.Y)
            tracer.Visible = TracersEnabled

            -- Update username
            username.Position = Vector2.new(headPos.X, headPos.Y - 20) -- Above the player's head
            username.Visible = ESPEnabled

            -- Update Corner Box
            if CornerBoxEnabled then
                local topLeft = Vector2.new(rootPos.X - size.X / 2, rootPos.Y - size.Y / 2)
                local topRight = Vector2.new(rootPos.X + size.X / 2, rootPos.Y - size.Y / 2)
                local bottomLeft = Vector2.new(rootPos.X - size.X / 2, rootPos.Y + size.Y / 2)
                local bottomRight = Vector2.new(rootPos.X + size.X / 2, rootPos.Y + size.Y / 2)

                -- Draw top corners
                corners[1].From = topLeft
                corners[1].To = Vector2.new(topLeft.X + 10, topLeft.Y)
                corners[1].Visible = true

                corners[2].From = topLeft
                corners[2].To = Vector2.new(topLeft.X, topLeft.Y + 10)
                corners[2].Visible = true

                corners[3].From = topRight
                corners[3].To = Vector2.new(topRight.X - 10, topRight.Y)
                corners[3].Visible = true

                corners[4].From = topRight
                corners[4].To = Vector2.new(topRight.X, topRight.Y + 10)
                corners[4].Visible = true

                -- Draw bottom corners
                corners[5].From = bottomLeft
                corners[5].To = Vector2.new(bottomLeft.X + 10, bottomLeft.Y)
                corners[5].Visible = true

                corners[6].From = bottomLeft
                corners[6].To = Vector2.new(bottomLeft.X, bottomLeft.Y - 10)
                corners[6].Visible = true

                corners[7].From = bottomRight
                corners[7].To = Vector2.new(bottomRight.X - 10, bottomRight.Y)
                corners[7].Visible = true

                corners[8].From = bottomRight
                corners[8].To = Vector2.new(bottomRight.X, bottomRight.Y - 10)
                corners[8].Visible = true
            else
                for _, line in ipairs(corners) do
                    line.Visible = false
                end
            end
        else
            box.Visible = false
            tracer.Visible = false
            username.Visible = false
            for _, line in ipairs(corners) do
                line.Visible = false
            end
        end
    end

    -- Connect to RenderStepped
    local connection
    connection = RunService.RenderStepped:Connect(function()
        if not player.Parent then
            -- Clean up when the player leaves
            box:Remove()
            tracer:Remove()
            username:Remove()
            for _, line in ipairs(corners) do
                line:Remove()
            end
            connection:Disconnect()
        else
            updateESP()
        end
    end)
end

-- Add ESP for all players
for _, player in ipairs(Players:GetPlayers()) do
    createESP(player)
end

-- Add ESP for new players
Players.PlayerAdded:Connect(function(player)
    createESP(player)
end)

-- Toggles for ESP Features
ESPSection:toggle({
    name = "ESP Name",
    def = false,
    callback = function(value)
        ESPEnabled = value
        print("ESP Name:", ESPEnabled)
    end
})

ESPSection:toggle({
    name = "ESP Outline",
    def = false,
    callback = function(value)
        OutlineEnabled = value
        print("ESP Outline:", OutlineEnabled)
    end
})

ESPSection:toggle({
    name = "ESP Tracers",
    def = false,
    callback = function(value)
        TracersEnabled = value
        print("ESP Tracers:", TracersEnabled)
    end
})

ESPSection:toggle({
    name = "Corner Box ESP",
    def = false,
    callback = function(value)
        CornerBoxEnabled = value
        print("Corner Box ESP:", CornerBoxEnabled)
    end
})

-- Toggle for Trace Target
EspTargetSection:toggle({
    name = "Trace Target",
    def = false,
    callback = function(value)
        TraceTargetEnabled = value
        print("Trace Targets:", TraceTargetEnabled)
    end
})

-- Toggle for Highlight Target
EspTargetSection:toggle({
    name = "HighLight Target",
    def = false,
    callback = function(value)
        HighLightsEnabled = value
        print("Highlight Target:", HighLightsEnabled)
    end
})

-- Toggle for Skeleton Target
EspTargetSection:toggle({
    name = "Skeletone Target",
    def = false,
    callback = function(value)
        SkeletonesEnabled = value
        print("Skeleton Target:", SkeletonesEnabled)
    end
})

FiledOfViewSection:toggle({
    name = "Enabled",
    def = false,
    callback = function(value)
end})

FiledOfViewSection:slider({
    name = "Radius",
    def = 10, -- Default speed
    max = 500, -- Maximum speed
    min = 100, -- Minimum speed
    rounding = true,
    callback = function(value)
    end
})

FiledOfViewSection:slider({
    name = "Thickness",
    def = 1, -- Default speed
    max = 20, -- Maximum speed
    min = 1, -- Minimum speed
    rounding = true,
    callback = function(value)
    end
})

FiledOfViewSection:toggle({
    name = "Outline",
    def = false,
    callback = function(value)
end})

FiledOfViewSection:toggle({
    name = "Filled",
    def = false,
    callback = function(value)
end})

FiledOfViewSection:toggle({
    name = "Stick To Target",
    def = false,callback = function(value)
end})

visualization:toggle({
    name = "Notifications",
    def = false,
    callback = function(value)
end})

visualization:toggle({
    name = "HitMarker",
    def = false,
    callback = function(value)
end})

visualization:toggle({
    name = "Highlight",
    def = false,
    callback = function(value)
end})

visualization:toggle({
    name = "Highlight | Effect",
    def = false,
    callback = function(value)
        local character = LocalPlayer.Character
        if not character then
            print("Local player character not found.")
            return
        end

        if value then
            -- Enable glowing effect
            for _, part in ipairs(character:GetChildren()) do
                if part:IsA("BasePart") then
                    -- Check if the effect already exists
                    if not part:FindFirstChild("GlowEffect") then
                        -- Create a ParticleEmitter for the glow effect
                        local particle = Instance.new("ParticleEmitter")
                        particle.Name = "GlowEffect"
                        particle.Texture = "rbxassetid://258128463" -- Replace with a glowing texture ID
                        particle.LightEmission = 0.9 -- Makes it emit light
                        particle.Rate = 40 -- Moderate rate for a balanced effect
                        particle.Lifetime = NumberRange.new(0.4, 0.7) -- Slightly longer lifetime
                        particle.Size = NumberSequence.new({
                            NumberSequenceKeypoint.new(0, 0.4), -- Start slightly larger
                            NumberSequenceKeypoint.new(0.5, 0.7), -- Grow more
                            NumberSequenceKeypoint.new(1, 0.4) -- Shrink again
                        })
                        particle.Speed = NumberRange.new(0, 0) -- No movement
                        particle.Rotation = NumberRange.new(0, 360) -- Random rotation
                        particle.RotSpeed = NumberRange.new(8, 12) -- Moderate rotation speed
                        particle.Color = ColorSequence.new(Color3.fromRGB(255, 255, 255)) -- White glow
                        particle.Transparency = NumberSequence.new({
                            NumberSequenceKeypoint.new(0, 0.1), -- Almost fully visible at start
                            NumberSequenceKeypoint.new(1, 0.7) -- Fade out more gradually
                        })
                        particle.Parent = part
                    end
                end
            end
            print("Slightly higher glowing effect enabled for local player.")
        else
            -- Disable glowing effect
            for _, part in ipairs(character:GetChildren()) do
                if part:IsA("BasePart") and part:FindFirstChild("GlowEffect") then
                    part.GlowEffect:Destroy()
                end
            end
            print("Glowing effect disabled for local player.")
        end
    end
})

local ESPPicker = ESPSection:colorpicker({
    name = "ESP Color",
    cpname = nil,
    def = Color3.fromRGB(255,255,255),
    callback = function(value)
    color = value
end})

OtherStuffSection:toggle({
    name = "Safe Location",def = false,callback = function(value)
end})

TeleportsSection:button({
    name = "Food Shop 1",
    callback = function()
        if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
            LocalPlayer.Character.HumanoidRootPart.CFrame = CFrame.new(-327.67, 21.183, -293.753)
            print("Teleported to Food Shop 1.")
        else
            print("Failed to teleport. HumanoidRootPart not found.")
        end
    end
})

TeleportsSection:button({
    name = "Food Shop 2",
    callback = function()
        if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
            LocalPlayer.Character.HumanoidRootPart.CFrame = CFrame.new(490.573, 45.571, -625.479)
            print("Teleported to Food Shop 2.")
        else
            print("Failed to teleport. HumanoidRootPart not found.")
        end
    end
})

TeleportsSection:button({
    name = "Taco Store",
    callback = function()
        if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
            LocalPlayer.Character.HumanoidRootPart.CFrame = CFrame.new(569.873, 48.561, -479.331)
            print("Teleported to Taco Store.")
        else
            print("Failed to teleport. HumanoidRootPart not found.")
        end
    end
})

ArmourTeleportSection:button({
    name = "Medium Armour",
    callback = function()
        if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
            LocalPlayer.Character.HumanoidRootPart.CFrame = CFrame.new(534.695, 47.825, -636.639)
            print("Teleported to Medium Armour.")
        else
            print("Failed to teleport. HumanoidRootPart not found.")
        end
    end
})

GunsTeleport:button({
    name = "Uphill GunStore",
    callback = function()
        if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
            LocalPlayer.Character.HumanoidRootPart.CFrame = CFrame.new(490.573, 45.571, -625.479)
            print("Teleported to Uphill GunStore.")
        else
            print("Failed to teleport. HumanoidRootPart not found.")
        end
    end
})

GunsTeleport:button({
    name = "DownHill GunStore",
    callback = function()
        if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
            LocalPlayer.Character.HumanoidRootPart.CFrame = CFrame.new(-584.879, 5.815, -745.718)
            print("Teleported to DownHill GunStore.")
        else
            print("Failed to teleport. HumanoidRootPart not found.")
        end
    end
})

GunsTeleport:button({
    name = "Rpg",
    callback = function()
        if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
            LocalPlayer.Character.HumanoidRootPart.CFrame = CFrame.new(113.65, -29.25, -276.25)
            print("Teleported to Rpg.")
        else
            print("Failed to teleport. HumanoidRootPart not found.")
        end
    end
})

GunsTeleport:button({
    name = "lmg",
    callback = function()
        if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
            LocalPlayer.Character.HumanoidRootPart.CFrame = CFrame.new(-624.28, 20.746, -298.243)
            print("Teleported to lmg.")
        else
            print("Failed to teleport. HumanoidRootPart not found.")
        end
    end
})

PlacesSection:button({
    name = "Bank",
    callback = function()
        if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
            LocalPlayer.Character.HumanoidRootPart.CFrame = CFrame.new(-441.082, 36.141, -284.82)
            print("Teleported to Bank.")
        else
            print("Failed to teleport. HumanoidRootPart not found.")
        end
    end
})

PlacesSection:button({
    name = "Casino",
    callback = function()
        if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
            LocalPlayer.Character.HumanoidRootPart.CFrame = CFrame.new(-864.9, 19.25, -149)
            print("Teleported to Casino.")
        else
            print("Failed to teleport. HumanoidRootPart not found.")
        end
    end
})

PlacesSection:button({
    name = "School",
    callback = function()
        if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
            LocalPlayer.Character.HumanoidRootPart.CFrame = CFrame.new(-652.85, 19.25, 256.05)
            print("Teleported to School.")
        else
            print("Failed to teleport. HumanoidRootPart not found.")
        end
    end
})

PlacesSection:button({
    name = "Police Station",
    callback = function()
        if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
            LocalPlayer.Character.HumanoidRootPart.CFrame = CFrame.new(-245.995, 19.696, -114.904)
            print("Teleported to Police Station.")
        else
            print("Failed to teleport. HumanoidRootPart not found.")
        end
    end
})

PlacesSection:button({
    name = "Chruch",
    callback = function()
        if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
            LocalPlayer.Character.HumanoidRootPart.CFrame = CFrame.new(205.1, 19.25, -84.7)
            print("Teleported to Chruch.")
        else
            print("Failed to teleport. HumanoidRootPart not found.")
        end
    end
})

PlacesSection:button({
    name = "Hospital",
    callback = function()
        if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
            LocalPlayer.Character.HumanoidRootPart.CFrame = CFrame.new(101.195, 20.3, -483.9)
            print("Teleported to Hospital.")
        else
            print("Failed to teleport. HumanoidRootPart not found.")
        end
    end
})

-- Function to find the closest player to the cursor
local function getClosestPlayerToCursor()
    local closestPlayer = nil
    local shortestDistance = math.huge
    local mousePos = UserInputService:GetMouseLocation()

    for _, player in ipairs(Players:GetPlayers()) do
        if player ~= LocalPlayer and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
            local rootPart = player.Character.HumanoidRootPart
            local screenPos, onScreen = Camera:WorldToViewportPoint(rootPart.Position)

            if onScreen then
                local distance = (Vector2.new(screenPos.X, screenPos.Y) - mousePos).Magnitude
                if distance < shortestDistance then
                    shortestDistance = distance
                    closestPlayer = player
                end
            end
        end
    end

    return closestPlayer
end

-- Function to predict the target's future position
local function predictTargetPosition(target)
    if target and target.Character and target.Character:FindFirstChild("HumanoidRootPart") then
        local rootPart = target.Character.HumanoidRootPart
        local velocity = rootPart.Velocity
        local speed = velocity.Magnitude -- Calculate the speed of the target

        -- Adjust prediction strength based on speed
        local predictionStrength
        if speed > 50 then
            -- Macro users or fast runners
            predictionStrength = 0.5
        elseif speed > 10 then
            -- Normal runners
            predictionStrength = 0.3
        else
            -- Stationary players
            predictionStrength = 0.1
        end

        -- Predict the future position
        local predictedPosition = rootPart.Position + (velocity * predictionStrength)
        return predictedPosition
    end
    return nil
end

-- Function to smoothly orbit and lock onto the target
local function smoothOrbitAndKill(target)
    if not target or not target.Character or not target.Character:FindFirstChild("HumanoidRootPart") then
        print("Invalid target.")
        return
    end

    local rootPart = target.Character.HumanoidRootPart
    local humanoid = target.Character:FindFirstChild("Humanoid")
    print("Smooth orbiting and locking onto:", target.Name)

    task.spawn(function()
        local angle = 0
        while OrbitingTarget == target and RageLockEnabled and rootPart and humanoid and humanoid.Health > 0 do
            RunService.RenderStepped:Wait()

            -- Predict the target's future position
            local predictedPosition = predictTargetPosition(target)
            if not predictedPosition then
                print("Failed to predict target position. Stopping orbit.")
                OrbitingTarget = nil
                break
            end

            -- Orbit logic
            angle = angle + math.rad(50) -- Adjust rotation speed
            local orbitX = math.cos(angle) * (OrbitDistance + 10) -- Adjust orbit distance
            local orbitZ = math.sin(angle) * (OrbitDistance + 10)
            local orbitY = OrbitHeight
            local orbitPosition = predictedPosition + Vector3.new(orbitX, orbitY, orbitZ)

            if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
                -- Smoothly move the player's HumanoidRootPart to the orbit position
                LocalPlayer.Character.HumanoidRootPart.CFrame = LocalPlayer.Character.HumanoidRootPart.CFrame:Lerp(
                    CFrame.new(orbitPosition, predictedPosition),
                    0.3 -- Adjust this value for smoother transitions
                )
            end

            -- Keep the camera locked onto the predicted position
            local cameraPosition = workspace.CurrentCamera.CFrame.Position
            workspace.CurrentCamera.CFrame = CFrame.new(cameraPosition, predictedPosition)

            -- Stop if the target becomes invalid
            if not target.Character or not target.Character:FindFirstChild("HumanoidRootPart") then
                print("Target is invalid. Stopping orbit.")
                OrbitingTarget = nil
                break
            end
        end
    end)
end

-- Keybind to toggle orbiting
UserInputService.InputBegan:Connect(function(input, gameProcessed)
    if gameProcessed or not RageLockEnabled then return end

    if input.KeyCode == Enum.KeyCode.F then
        if OrbitingTarget then
            -- Stop orbiting the current target
            print("Stopped orbiting:", OrbitingTarget.Name)
            OrbitingTarget = nil
        else
            -- Find the closest player and start orbiting
            local target = getClosestPlayerToCursor()
            if target then
                OrbitingTarget = target
                smoothOrbitAndKill(target)
            else
                print("No valid target found near the cursor.")
            end
        end
    end
end)

RageLockSection:toggle({
    name = "Rage Lock | Closest To Mouse F",
    def = false,
    callback = function(value)
        RageLockEnabled = value -- Toggle to enable or disable the feature
        if RageLockEnabled then
            print("Rage Lock enabled. Press F to lock onto a target.")
        else
            print("Rage Lock disabled.")
            OrbitingTarget = nil -- Reset the target when disabled
        end
    end
})

RageLockSection:toggle({
name = "custom cursor",def = false,callback = function(value)
end})

RageLockSection:toggle({
name = "Goofy Anim | Floss",def = false,callback = function(value)
end})

OtherSection:toggle({
name = "Force Reset",def = false,callback = function(value)
end})

HitDetectionSection:toggle({
    name = "Indicators",
    def = false,
    callback = function(value)
        print("Indicators Enabled:", value)
    end
})

HitDetectionSection:toggle({
    name = "Custom Sounds",
    def = false,
    callback = function(value)
        print("Custom Sounds Enabled:", value)
    end
})

HitDetectionSection:slider({
    name = "Sounds Volume",
    def = 0,
    max = 100,
    min = 1,
    rounding = true, 
    callback = function(value)
        print("Sounds Volume Set To:", value)
    end
})

HitDetectionSection:dropdown({
    name = "Sounds",
    def = "RIFK7",
    max = 4,
    options = {"RIFK7", "Bubble", "Cod"},
    callback = function(chosen)
        print("Selected Sound:", chosen)
    end
})

HitDetectionSection:toggle({
    name = "Hit Chams",
    def = false,
    callback = function(value)
        print("Hit Chams Enabled:", value)
    end
})

HitDetectionSection:dropdown({
    name = "Hit Cham Method",
    def = "BasePart",
    max = 2,
    options = {"BasePart", "Clone"},
    callback = function(chosen)
        print("Selected Hit Cham Method:", chosen)
    end
})

local picker = HitDetectionSection:colorpicker({
    name = "color",
    cpname = nil,
    def = Color3.fromRGB(255, 255, 255),
    callback = function(value)
        print("Selected Color:", value)
    end
})

-- Sticky Aim Logic
RunService.RenderStepped:Connect(function()
    if AimbotActive and CurrentTarget and CurrentTarget.Character and CurrentTarget.Character:FindFirstChild("HumanoidRootPart") then
        local predictedPosition = predictTargetPosition(CurrentTarget)

        if predictedPosition then
            if StickyAim then
                -- Directly lock onto the target
                Camera.CFrame = CFrame.new(Camera.CFrame.Position, predictedPosition)
            else
                -- Smoothly interpolate (lerp) to the target
                Camera.CFrame = Camera.CFrame:Lerp(CFrame.new(Camera.CFrame.Position, predictedPosition), 0.5)
            end
        end

        -- Check if the target is knocked
        if isKnocked(CurrentTarget) then
            createNotification(CurrentTarget.Name)
            CurrentTarget = nil
        end
    end
end)

-- Aimbot Logic
UserInputService.InputBegan:Connect(function(input, gameProcessed)
    if gameProcessed then return end

    if input.KeyCode == AimKey then
        AimbotActive = not AimbotActive

        if AimbotActive then
            -- Find the closest player to target
            CurrentTarget = findClosestPlayer()
            if CurrentTarget then
                print("Aimbot Enabled. Targeting:", CurrentTarget.Name)
            else
                print("Aimbot Enabled. No target found.")
            end
        else
            -- Disable aimbot
            CurrentTarget = nil
            print("Aimbot Disabled.")
        end
    end
end)

-- Function to find the closest player within the FOV
local function findClosestPlayer()
    local closestPlayer = nil
    local shortestDistance = FOVRadius

    for _, player in ipairs(Players:GetPlayers()) do
        if player ~= LocalPlayer and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
            local rootPart = player.Character.HumanoidRootPart
            local screenPos, onScreen = Camera:WorldToViewportPoint(rootPart.Position)

            if onScreen then
                local mousePos = UserInputService:GetMouseLocation()
                local distance = (Vector2.new(screenPos.X, screenPos.Y) - mousePos).Magnitude

                if distance < shortestDistance then
                    shortestDistance = distance
                    closestPlayer = player
                end
            end
        end
    end

    return closestPlayer
end

-- Notification System
local function createNotification(playerName)
    -- Create the notification UI
    local screenGui = Instance.new("ScreenGui")
    screenGui.Name = "NotificationUI"
    screenGui.Parent = LocalPlayer:WaitForChild("PlayerGui")

    local notificationFrame = Instance.new("Frame")
    notificationFrame.Size = UDim2.new(0, 300, 0, 50)
    notificationFrame.Position = UDim2.new(0, 10, 0.5, -25)
    notificationFrame.BackgroundColor3 = Color3.fromRGB(50, 50, 50)
    notificationFrame.BorderSizePixel = 0
    notificationFrame.AnchorPoint = Vector2.new(0, 0.5)
    notificationFrame.Parent = screenGui

    local outline = Instance.new("UIStroke")
    outline.Color = Color3.fromRGB(255, 255, 255)
    outline.Thickness = 2
    outline.Parent = notificationFrame

    local textLabel = Instance.new("TextLabel")
    textLabel.Size = UDim2.new(1, 0, 1, 0)
    textLabel.BackgroundTransparency = 1
    textLabel.Text = "Knocked: " .. playerName
    textLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
    textLabel.Font = Enum.Font.SourceSansBold
    textLabel.TextSize = 20
    textLabel.Parent = notificationFrame

    -- Tween animation for fading out the notification
    local tween = TweenService:Create(notificationFrame, TweenInfo.new(2, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {BackgroundTransparency = 1, Position = UDim2.new(0, 10, 0.5, -75)})
    tween:Play()
    tween.Completed:Connect(function()
        screenGui:Destroy()
    end)
end

-- Prediction Logic
local function predictTargetPosition(target)
    if target and target.Character and target.Character:FindFirstChild("HumanoidRootPart") then
        local rootPart = target.Character.HumanoidRootPart
        local velocity = rootPart.Velocity
        local predictedPosition = rootPart.Position + (velocity * PredictionStrength * RunService.Heartbeat:Wait())
        return predictedPosition
    end
    return nil
end